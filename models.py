from flask_sqlalchemy import SQLAlchemy
from flask_login import UserMixin
from werkzeug.security import generate_password_hash, check_password_hash
from datetime import datetime

db = SQLAlchemy()

class User(UserMixin, db.Model):
    """User accounts"""
    __tablename__ = 'users'
    
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(255), nullable=False)
    is_admin = db.Column(db.Boolean, default=False)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    last_login = db.Column(db.DateTime)
    
    # Relationships
    meetings = db.relationship('Meeting', backref='user', lazy=True, cascade='all, delete-orphan')
    
    def set_password(self, password):
        """Hash and set password"""
        self.password_hash = generate_password_hash(password)
    
    def check_password(self, password):
        """Check if password matches"""
        return check_password_hash(self.password_hash, password)
    
    def __repr__(self):
        return f'<User {self.username}>'


class Meeting(db.Model):
    """Racing meetings uploaded by users"""
    __tablename__ = 'meetings'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    meeting_name = db.Column(db.String(200), nullable=False)
    track = db.Column(db.String(100))
    date = db.Column(db.Date)
    csv_data = db.Column(db.Text)  # Store original CSV
    uploaded_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    # Relationships
    races = db.relationship('Race', backref='meeting', lazy=True, cascade='all, delete-orphan')
    
    def __repr__(self):
        return f'<Meeting {self.meeting_name}>'


class Race(db.Model):
    """Individual races within a meeting"""
    __tablename__ = 'races'
    
    id = db.Column(db.Integer, primary_key=True)
    meeting_id = db.Column(db.Integer, db.ForeignKey('meetings.id'), nullable=False)
    race_number = db.Column(db.Integer, nullable=False)
    distance = db.Column(db.String(50))
    race_class = db.Column(db.String(50))
    track_condition = db.Column(db.String(50))

    
    # Relationships
    horses = db.relationship('Horse', backref='race', lazy=True, cascade='all, delete-orphan')
    
    def __repr__(self):
        return f'<Race {self.meeting_id}-{self.race_number}>'


class Horse(db.Model):
    """Horses in each race with all their data"""
    __tablename__ = 'horses'
    
    id = db.Column(db.Integer, primary_key=True)
    race_id = db.Column(db.Integer, db.ForeignKey('races.id'), nullable=False)
    horse_name = db.Column(db.String(100), nullable=False)
    barrier = db.Column(db.Integer)
    weight = db.Column(db.Float)
    jockey = db.Column(db.String(100))
    trainer = db.Column(db.String(100))
    form = db.Column(db.String(50))
    
    # Store all CSV data as JSON for flexibility
    csv_data = db.Column(db.JSON)
    is_scratched = db.Column(db.Boolean, default=False)  # NEW LINE
    
    # Relationships
    prediction = db.relationship('Prediction', backref='horse', uselist=False, cascade='all, delete-orphan')
    
    def __repr__(self):
        return f'<Horse {self.horse_name}>'


class Prediction(db.Model):
    """Predictions/scores generated by your algorithm"""
    __tablename__ = 'predictions'
    
    id = db.Column(db.Integer, primary_key=True)
    horse_id = db.Column(db.Integer, db.ForeignKey('horses.id'), nullable=False)
    score = db.Column(db.Float, nullable=False)
    predicted_odds = db.Column(db.String(20))
    win_probability = db.Column(db.String(20))
    performance_component = db.Column(db.String(20))
    base_probability = db.Column(db.String(20))
    notes = db.Column(db.Text)
    calculated_at = db.Column(db.DateTime, default=datetime.utcnow)
    best_bet_flagged_at = db.Column(db.DateTime, nullable=True)  # NEW: Track when this appeared on Best Bets
    
    def __repr__(self):
        return f'<Prediction {self.horse_id}: {self.score}>'
        
class Result(db.Model):
    """Actual race results for tracking model performance
    
    finish_position codes:
    - 1, 2, 3, 4 = actual finishing positions
    - 5 = unplaced (ran but finished 5th or worse)
    - 0 = scratched (did not run)
    """
    __tablename__ = 'results'
    
    id = db.Column(db.Integer, primary_key=True)
    horse_id = db.Column(db.Integer, db.ForeignKey('horses.id'), nullable=False)
    finish_position = db.Column(db.Integer, nullable=False)  # 0=scratched, 1-4=placed, 5=unplaced
    sp = db.Column(db.Float, nullable=True)  # NULL for scratched horses
    recorded_at = db.Column(db.DateTime, default=datetime.utcnow)
    recorded_by = db.Column(db.Integer, db.ForeignKey('users.id'))
    
    # Relationships
    horse = db.relationship('Horse', backref=db.backref('result', uselist=False, cascade='all, delete-orphan'))
    user = db.relationship('User', backref='recorded_results')
    
    @property
    def is_scratched(self):
        """Check if this horse was scratched"""
        return self.finish_position == 0
    
    @property
    def actually_ran(self):
        """Check if this horse actually competed"""
        return self.finish_position > 0
    
    def __repr__(self):
        if self.finish_position == 0:
            return f'<Result {self.horse_id}: SCRATCHED>'
        return f'<Result {self.horse_id}: P{self.finish_position} @ ${self.sp}>'


class Component(db.Model):
    """Betting components with performance tracking for Best Bets feature"""
    __tablename__ = 'components'
    
    id = db.Column(db.Integer, primary_key=True)
    component_name = db.Column(db.String(200), unique=True, nullable=False)
    is_active = db.Column(db.Boolean, default=True)  # Show on Best Bets page
    min_roi = db.Column(db.Float, default=10.0)  # Minimum ROI threshold
    min_appearances = db.Column(db.Integer, default=10)  # Minimum sample size
    
    # Display stats (manually updated by you from Data page)
    appearances = db.Column(db.Integer, default=0)
    wins = db.Column(db.Integer, default=0)
    strike_rate = db.Column(db.Float, default=0.0)
    roi_percentage = db.Column(db.Float, default=0.0)
    
    notes = db.Column(db.Text)  # Optional notes about this component
    last_updated = db.Column(db.DateTime, default=datetime.utcnow)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    def __repr__(self):
        return f'<Component {self.component_name}: {self.roi_percentage}% ROI>'
    
    @property
    def display_label(self):
        """Formatted label for display"""
        if self.appearances > 0:
            return f"{self.component_name} ({self.strike_rate:.1f}% SR, {self.roi_percentage:+.1f}% ROI, N={self.appearances})"
        return self.component_name


class ChatMessage(db.Model):
    """Chat messages between users and Claude AI assistant"""
    __tablename__ = 'chat_messages'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    role = db.Column(db.String(20), nullable=False)  # 'user' or 'assistant'
    content = db.Column(db.Text, nullable=False)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)
    session_id = db.Column(db.String(50))
    
    user = db.relationship('User', backref='chat_messages')
    
    def __repr__(self):
        return f'<ChatMessage {self.role}: {self.content[:30]}...>'
